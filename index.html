<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Eyes Following Cursor</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-color: #000;
        cursor: crosshair;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <canvas id="eyeCanvas"></canvas>

    <script>
      const canvas = document.getElementById("eyeCanvas");
      const ctx = canvas.getContext("2d");

      // Set canvas size
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      resizeCanvas();
      window.addEventListener("resize", resizeCanvas);

      // Mouse position
      let mouseX = canvas.width / 2;
      let mouseY = canvas.height / 2;

      // Eye parameters
      const eyeWidth = 25;
      const eyeHeight = 25;
      const eyeSpacing = 35;
      const pupilRadius = 13;
      const irisRadius = 8;
      const pupilYOffset = -4; // Negative value moves pupils up, positive moves down

      // Track mouse movement
      canvas.addEventListener("mousemove", (e) => {
        mouseX = e.clientX;
        mouseY = e.clientY;
      });

      function drawEye(centerX, centerY, pairCenterX, pairCenterY) {
        // Calculate angle from pair center to mouse (for dead zone)
        const dxFromPairCenter = mouseX - pairCenterX;
        const dyFromPairCenter = mouseY - pairCenterY;
        const distanceFromPairCenter = Math.sqrt(
          dxFromPairCenter * dxFromPairCenter +
            dyFromPairCenter * dyFromPairCenter
        );

        // Calculate angle from individual eye to mouse (for pupil direction)
        const dx = mouseX - centerX;
        const dy = mouseY - centerY;
        const angle = Math.atan2(dy, dx);

        // Dead zone threshold - if mouse is too close to pair center, keep pupils centered
        const deadZoneRadius = 50;
        const maxOffset = 8;

        let pupilX = centerX;
        let pupilY = centerY + pupilYOffset;

        if (distanceFromPairCenter > deadZoneRadius) {
          // Only move pupils if mouse is outside dead zone
          const adjustedDistance = Math.min(
            (distanceFromPairCenter - deadZoneRadius) / 30,
            maxOffset
          );
          pupilX = centerX + Math.cos(angle) * adjustedDistance;
          pupilY = centerY + pupilYOffset + Math.sin(angle) * adjustedDistance;
        }

        // Draw eyeball (white part) with sharp wedge shape
        ctx.save();

        // Solid white/light gray fill
        ctx.fillStyle = "#e8e8e8";
        ctx.beginPath();

        // Create wedge/almond shape with sharp corners
        ctx.moveTo(centerX - eyeWidth, centerY);
        ctx.quadraticCurveTo(
          centerX,
          centerY - eyeHeight,
          centerX + eyeWidth,
          centerY
        );
        ctx.quadraticCurveTo(
          centerX,
          centerY + eyeHeight,
          centerX - eyeWidth,
          centerY
        );
        ctx.closePath();
        ctx.fill();
        ctx.restore();

        // Draw pupil (black part)
        ctx.fillStyle = "#000000";
        ctx.beginPath();
        ctx.arc(pupilX, pupilY, pupilRadius, 0, Math.PI * 2);
        ctx.fill();
      }

      function animate() {
        // Clear canvas
        ctx.fillStyle = "#000000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Calculate grid dimensions for eye pairs
        const pairWidth = eyeSpacing * 2 + eyeWidth * 3.5; // Total width needed for a pair
        const pairHeight = eyeHeight * 2.5; // Total height with spacing

        const cols = Math.floor(canvas.width / pairWidth);
        const rows = Math.floor(canvas.height / pairHeight);

        // Calculate starting position to center the grid
        const totalWidth = cols * pairWidth;
        const totalHeight = rows * pairHeight;
        const startX = (canvas.width - totalWidth) / 2 + pairWidth / 2;
        const startY = (canvas.height - totalHeight) / 2 + pairHeight / 2;

        // Draw grid of eye pairs
        for (let row = 0; row < rows; row++) {
          for (let col = 0; col < cols; col++) {
            const pairCenterX = startX + col * pairWidth;
            const pairCenterY = startY + row * pairHeight;

            drawEye(
              pairCenterX - eyeSpacing,
              pairCenterY,
              pairCenterX,
              pairCenterY
            );
            drawEye(
              pairCenterX + eyeSpacing,
              pairCenterY,
              pairCenterX,
              pairCenterY
            );
          }
        }

        requestAnimationFrame(animate);
      }

      // Start animation
      animate();
    </script>
  </body>
</html>
